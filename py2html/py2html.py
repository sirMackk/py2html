# PythonParse

from sys import argv, exit
from tokenize import generate_tokens
from token import tok_name
from keyword import iskeyword
from cgi import escape
from cStringIO import StringIO

class PythonParse(object):



    def __init__(self, input, cli, nums):  
        '''
        The class does most of the work automatically though the constructor. 
        The user is mostly interested in passing the correct parameters to the object.
        The first parameter is the name of a python source code file. The second parameter
        is either True/False and indicates whether html tags should use inline styles (false)
        or a an internal style sheet (true). If returning an html file, True is recommended.
        The final parameter 'nums' is an option to number the lines in the output, although
        this is just a small extra and doesn't format the text as nicely.
        '''
        _version = 'version 0.2'

        #Global color vars. Changing them will change the output colors.
        _colors = {'keyword': '0000CD', 'definition': 'FF00FF', 
                    'numbers': 'FF8C00', 'strings': 'A9A9A9', 
                    'comments': '008000', 'background': '228b11',
                    'text': '000000', 'code_background': 'FFFFFF'}
        self._header = '''
<!DOCTYPE html>
<!-- Generated by py2html %s -->
<html><head>
<style type="text/css">
body {''' % _version
        self._style_main = ('background-color:#%s;\n' % _colors['background'] + 
                            'color:#%s;\n}\n#main_container' % _colors['text'] +
                            '{\nbackground-color:#%s;\n' % _colors['code_background'])




        self._header2 = '''

width:95%;
height:auto;
padding:25px;
font-family:courier new;
}
''' 
        self._style_colors = ('.ifdef {\ncolor:#%s;\n}\n\n.def' % _colors['keyword'] +
                            '{\ncolor:#%s;\n}\n.int ' % _colors['definition'] +
                            '{\ncolor:#%s;\n}\n.str ' % _colors['numbers'] +
                            '{\ncolor:#%s;\n}\n.comm ' % _colors ['strings'] +
                            '{\ncolor:#%s;\n}\n' % _colors['comments'])



        self._header_end = '''
</style></head>
<body>
<div id="main_container"><pre>
''' 

        self._trailer = '''</pre></div></body>
                </html>''' 
        

        if cli:
            self._style = {'def': '<span class="def">',
                            'int': '<span class="int">',
                            'str': '<span class="str">',
                            'comm': '<span class="comm">',
                            'ifdef': '<span class="ifdef">'}
        else:
            self._style = {'def': '<span style="color:#%s;">' % _colors['definition'],
                'int': '<span style="color:#%s;">' % _colors['numbers'],
                'str': '<span style="color:#%s;">' % _colors['strings'],
                'comm': '<span style="color:#%s;">' % _colors['comments'],
                'ifdef': '<span style="color:#%s;">' % _colors['keyword']}
        
        self.name = input
        self._indent = ''
        try:
            self._input = open(input)
        except IOError:
            print '%s - file does not exist' % input
            exit()

        self._output = StringIO()
        self.analyze()
        if nums:
            self.number_lines()


    def __del__(self):
        '''
        Destructor, will close all file/cStringIO objects
        '''
        try:
            self._input.close()
            self._output.close()
        except AttributeError:
            print "Error, probably in __init__"
            exit()

    def get_code(self):
        '''
        This function returns a copy of a cStringIO object of the formatted output.
        Useful if ParsePython is used in web-dev
        '''
        
        return '<pre>' + self._output.getvalue() + '</pre>'

    def write_out(self):
        '''
        This functions tries to open a file for writing, writes the header,
        the html formatted source code and the trailer and closes the file.
        Use this to get .html file output.
        '''
        try:
            write_out = open('%s.html' % self.name[:-3], 'w')
        except IOError:
            print "Write error detected, check permissions"
            exit()
        write_out.write(self._header)
        write_out.write(self._style_main)

        write_out.write(self._header2)
        write_out.write(self._style_colors)
        write_out.write(self._header_end)
        write_out.write(self._output.getvalue())
        write_out.write(self._trailer)
        write_out.close()

    def number_lines(self):
        '''Function for numbering the lines of an already formatted
        cStringIO object.
        '''
        temp = StringIO()
        i = 0
        for line in self.get_code():
            temp.write('%d %s' % (i, line))
            i += 1
            
        self._output = temp
                   
    def analyze(self):
        '''
        This function used the input object to iterate through it using the
        generate_tokens function from the tokenize module and to pad everything
        with the appropriate whitespace and html tags
        '''
        function = False
        tokens = generate_tokens(self._input.readline)
        for toknum, tokval, (srow, scol), (erow, ecol), line in tokens:
            out = ''
            space = ''

            if ecol <= len(line)-2:
                if line[ecol] == ' ':
                    space = ' '

            tokname = tok_name[toknum]
            if tokname == 'NEWLINE' or tokname == 'NL':
                self._output.write('\n%s' % self._indent)
            elif tokname == 'INDENT':
                self._output.write('    ')
                self._indent += '    '
                
            elif tokname == 'DEDENT':
                
                self._output.seek(-4, 1)
                self._indent = self._indent[:-4]

            elif iskeyword(tokval) or tokval == '(' or tokval == ')':
                if tokval.lower() == 'def':
                    function = True
                out = '%s<b>%s</b></span>' % (self._style['ifdef'], tokval)

            elif tokname == 'NAME' or tokname == 'OP':
                if function == True:
                    out = '%s<b>%s</b></span>' % (self._style['def'], tokval)
                    function = False
                else:
                    out = tokval
                                     
            elif tokname == 'NUMBER':
                out = '%s<b>%s</b></span>' % (self._style['int'], tokval)

            elif tokname == 'STRING':
                if tokval[:3] == '\'\'\'':
                    out = '%s<b>%s</b></span>' % (self._style['int'], escape(tokval))
                else:
                    out = '%s%s</span>' % (self._style['str'], escape(tokval))
              
            elif tokname == 'COMMENT':
                out = '%s<b>%s</b></span>' % (self._style['comm'], escape(tokval))

            else:
                self._output.write(out)

            self._output.write('%s%s' % (out, space))

try:     
    script, name = argv
except ValueError:
    print "Incorrect input"
    print "Correct input has form - 'py2html.py name_of_file.py'"
    exit()   

parsed = PythonParse(name, True, False)
parsed.write_out()


